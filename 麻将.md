**麻将**



**v3**

- 网络协议使用 http 连接

- 引入状态机

- 引入缓存

  - Spring Cache
  - Redis
  - 本地自实现

- 任务列表

  - ```bash
    编号#1
    TODO 多次点击登录 会出现返回值不一致的情况
    原因：
    	1.服务器没有为每个玩家单独创建一个状态机，而是共享一个状态机，所以当一个玩家的状态改变后，会影响到其他玩家
    	2.服务器与客户端的状态机之间的状态没有进行同步 导致状态不一致
    状态：
        待解决
    解决方案：
        
    ```

  - ```bash
    编号#2
    TODO 异步状态下，在无法获取服务端的响应下就进行了状态的转换
    原因：
    	1.没有将后台任务整体封装为异步任务，而是一部分由 UI 线程执行，一部分由异步线程执行
    状态：
    	已解决/2021/12/23 guangmingdexin
    解决方案：
    	对所有后台事件，统一使用异步回调
    ```

  - ```bash
    编号#3
    TODO 巨大隐患，当服务器没有即时响应之后，重复点击事件会不断一直创建客户端异步线程去发送请求
    原因：
    	由于使用异步事件编程机制，用户在操作事件时，可以不用等待服务器结果的返回
    状态：
    	待解决
    解决方案：
    	前端方案：
    	1.对界面做操作限制，当点击过后，直接变灰或者显示 loading 状态，直到服务器操作成功，界面再执行相应回调
    	2.点击之后，直接进行跳转到其他界面，再由服务器返回结果渲染界面
    	后端方案：
    	1.根据业务/事件 id + 玩家用户名（类似于：guangmingdexin:时间戳:EVENT_LOGIN_ID）,将这个请求消息缓存在本地中，使用一个类似于 map 的记录，如果当小于多少时间频繁请求，直接请求失败，也可以防止无限制的创建异步线程
    	2.是否可以使用布隆过滤器，只要存在则说明发出过请求了（如何定时更新）
    ```

  - ```bash
    编号#4
    TODO 工具类 ClassUtil 扫描某个包下的所有包含某个注解类的方法出现错误，抛出异常java.lang.ClassNotFoundException
    原因：
    	拼接的类全限定名称错误
    	拼接后的全限定名称 ds.guang.majiang.server.layer.PrepareAction 
    	实际的全限定名称 ds.guang.majiang.server.layer.basic.PrepareAction 
    状态：
    	已解决/2021/12/24 guangmingdexin
    解决方案：
    	修改工具类代码
    ```

  - ```bash
    编号#5
    TODO 统一框架当中所有使用缓存的地方
    状态：
    	待解决
    解决方案：
    	
    ```

  - ```bash
    编号#6
    TODO 游戏匹配池设计线程安全问题
    原因：
    	原始设计方案 阻塞队列 + Future + 线程池（只有一个线程）
    	缺陷：1.死锁，阻塞在 future.get()[在执行在 get 之前，阻塞队列中的所有元素都被出队了，所以此时条件判断不满足，一直阻塞]
    		 2.阻塞消耗大（争夺阻塞队列的锁）
    		 3.将 NioEventLoop 线程阻塞了，降低了真个系统的吞吐量
    		
    状态：
    	待解决
    解决方案：
    	1.引入 MPSC (多生产者单消费者)队列，具体如何设计还需要考虑
    	
    ```
    
    原始设计：
    
    ![](C:\Users\guangyong.deng\Desktop\project\majiang\record-png\match-pool.png)
    
  - ```bash
    编号#7
    TODO 用户与 Channel绑定
    原因：
    	玩家在游戏匹配池匹配成功后，需要在异步线程中将匹配成功后的信息回传给客户端，此时就涉及到了如何获取玩家客户端的能力
    	原始设计方案：Map<PId, Channel>
        缺陷：
        	1.如何清理不在线的客户端
    	// 缺陷：1.在 http 中，http 是无状态的，需要维持 http 的长连接（待测试！）
    	//	 2.Channel 是无法序列化的（通过网卡绑定）
    	//	 3.接收到一条消息又任何证明这条通道是可信的
    状态：
    	待解决
    解决方案：
    	
    ```
  
  - ```
    编号#8
    TODO 在 ChannelHandler 中开启线程发送消息，NioEventLoop 会将此次发送消息封装为一个任务，加入到任务队列中，但不知为何，最终该任务没有被 NioEventLoop 执行
    原因：
    	一：通过抓包分析，发现服务器没有正常回复
    		1.服务器没有将返回值封装为 netty 支持的数据类型，即 bytebuf
    		2.由于缓存了 ChannelHandlerContext, 但是每一次连接，由于线程选择器的存在，都是由不同的线程处理，所以造成了在不同的NioEventLoop 下处理其他线程缓存的 ChannelHandlerContext 但是不知道为什么异常没有抛出来了，具体原因有待分析
    	分析：
    		1.通过 debug 可知，任务被正常提交给了 NioEventLoop
    		2.注意通信的时候到底是使用 NioServerSocketChannel 还是NioSocketChannel 
    ? 通过理论分析Socket 通信可知，ServerSocket 一般是处理连接，当有新连接进来的时候，会创建一个新的Socket 用于通信，所以应该是通过 NioSocketChannel 进行实际的通信，而NioSocketChannel 是不支持直接发送 POJO 对象的，所以发送异常
    	
    状态：
    	已解决/2022/1/6 guangmingdexin 
    解决方案：
    	不将 ChannelHandleContext 缓存为全局变量，而是每次处理时，单独设置到 DsMessage 中，由处理消息的状态机取出来单独处理
    ```
    
  - ```
    编号#9
    TODO 状态之间如何通信
    ```
  
  - ```
    编号#10
    TODO 出现错误信息，消息将无法发送给客户端
    原因：
    	netty 的异常捕捉机制
    状态：
    	未解决
    解决方案：
    	
    ```
  
  - 
  
    
  
  

