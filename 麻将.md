**麻将**



**v3**

- 网络协议使用 http 连接

- 引入状态机

- 引入缓存

  - Spring Cache
  - Redis
  - 本地自实现

- 任务列表

  
  
  - ```bash
    编号#1
    TODO 多次点击登录 会出现返回值不一致的情况
    原因：
    	1.服务器没有为每个玩家单独创建一个状态机，而是共享一个状态机，所以当一个玩家的状态改变后，会影响到其他玩家
    	2.服务器与客户端的状态机之间的状态没有进行同步 导致状态不一致
    状态：
        待解决
    解决方案：
        
    ```
  
  - ```bash
    编号#2
    TODO 异步状态下，在无法获取服务端的响应下就进行了状态的转换
    原因：
    	1.没有将后台任务整体封装为异步任务，而是一部分由 UI 线程执行，一部分由异步线程执行
    状态：
    	已解决/2021/12/23 guangmingdexin
    解决方案：
    	对所有后台事件，统一使用异步回调
    ```
  
  - ```bash
    编号#3
    TODO 巨大隐患，当服务器没有即时响应之后，重复点击事件会不断一直创建客户端异步线程去发送请求
    原因：
    	由于使用异步事件编程机制，用户在操作事件时，可以不用等待服务器结果的返回
    状态：
    	待解决
    解决方案：
    	前端方案：
    	1.对界面做操作限制，当点击过后，直接变灰或者显示 loading 状态，直到服务器操作成功，界面再执行相应回调
    	2.点击之后，直接进行跳转到其他界面，再由服务器返回结果渲染界面
    	后端方案：
    	1.根据业务/事件 id + 玩家用户名（类似于：guangmingdexin:时间戳:EVENT_LOGIN_ID）,将这个请求消息缓存在本地中，使用一个类似于 map 的记录，如果当小于多少时间频繁请求，直接请求失败，也可以防止无限制的创建异步线程
    	2.是否可以使用布隆过滤器，只要存在则说明发出过请求了（如何定时更新）
    ```
  
  - ```bash
    编号#4
    TODO 工具类 ClassUtil 扫描某个包下的所有包含某个注解类的方法出现错误，抛出异常java.lang.ClassNotFoundException
    原因：
    	拼接的类全限定名称错误
    	拼接后的全限定名称 ds.guang.majiang.server.layer.PrepareAction 
    	实际的全限定名称 ds.guang.majiang.server.layer.basic.PrepareAction 
    状态：
    	已解决/2021/12/24 guangmingdexin
    解决方案：
    	修改工具类代码
    ```
  
  - ```bash
    编号#5
    TODO 统一框架当中所有使用缓存的地方
    状态：
    	待解决
    解决方案：
    	
    ```
  
  - ```bash
    编号#6
    TODO 游戏匹配池设计线程安全问题
    原因：
    	原始设计方案 阻塞队列 + Future + 线程池（只有一个线程）
    	缺陷：1.死锁，阻塞在 future.get()[在执行在 get 之前，阻塞队列中的所有元素都被出队了，所以此时条件判断不满足，一直阻塞]
    		 2.阻塞消耗大（争夺阻塞队列的锁）
    		 3.将 NioEventLoop 线程阻塞了，降低了真个系统的吞吐量
    		
    状态：
    	待解决
    解决方案：
    	1.引入 MPSC (多生产者单消费者)队列，具体如何设计还需要考虑
    	
    ```
    
    原始设计：
    
    ![](C:\Users\guangyong.deng\Desktop\project\majiang\record-png\match-pool.png)
    
  - ```bash
    编号#7
    TODO 用户与 Channel绑定
    原因：
    	玩家在游戏匹配池匹配成功后，需要在异步线程中将匹配成功后的信息回传给客户端，此时就涉及到了如何获取玩家客户端的能力
    	原始设计方案：Map<PId, Channel>
        缺陷：
        	1.如何清理不在线的客户端
    	// 缺陷：1.在 http 中，http 是无状态的，需要维持 http 的长连接（待测试！）
    	//	 2.Channel 是无法序列化的（通过网卡绑定）
    	//	 3.接收到一条消息又任何证明这条通道是可信的
    状态：
    	待解决
    解决方案：
    	
    ```
  
  - ```
    编号#8
    TODO 在 ChannelHandler 中开启线程发送消息，NioEventLoop 会将此次发送消息封装为一个任务，加入到任务队列中，但不知为何，最终该任务没有被 NioEventLoop 执行
    原因：
    	一：通过抓包分析，发现服务器没有正常回复
    		1.服务器没有将返回值封装为 netty 支持的数据类型，即 bytebuf
    		2.由于缓存了 ChannelHandlerContext, 但是每一次连接，由于线程选择器的存在，都是由不同的线程处理，所以造成了在不同的NioEventLoop 下处理其他线程缓存的 ChannelHandlerContext 但是不知道为什么异常没有抛出来了，具体原因有待分析
    	分析：
    		1.通过 debug 可知，任务被正常提交给了 NioEventLoop
    		2.注意通信的时候到底是使用 NioServerSocketChannel 还是NioSocketChannel 
    ? 通过理论分析Socket 通信可知，ServerSocket 一般是处理连接，当有新连接进来的时候，会创建一个新的Socket 用于通信，所以应该是通过 NioSocketChannel 进行实际的通信，而NioSocketChannel 是不支持直接发送 POJO 对象的，所以发送异常
    	
    状态：
    	已解决/2022/1/6 guangmingdexin 
    解决方案：
    	不将 ChannelHandleContext 缓存为全局变量，而是每次处理时，单独设置到 DsMessage 中，由处理消息的状态机取出来单独处理
    ```
    
  - ```
    编号#9
    TODO 状态之间如何通信
    ```
  
  - ```
    编号#10
    TODO 出现错误信息，消息将无法发送给客户端
    原因：
    	netty 的异常捕捉机制
    状态：
    	未解决
    解决方案：
    	
    ```
  
  - ```
    编号#11
    TODO: 在玩家第一次请求手牌的时候，如果发现玩家手牌为空，则进行初始化操作，但是多线程环境下，可能出现多次初始化，出现线程安全问题
    原因：
    	 if(cards == null) {
             // 说明此时玩家还未进行分配
             room.assignCardToPlayer();
             cards = player.getCards();
         }
    状态：
    	未解决
    解决方案：
    	1.上锁，保证只有一个线程能够访问，但是由于这段逻辑处于 NioEventLoop 中，最好不要阻塞
    	2.使用 CAS 操作，设置一个初始化状态变量，同样需要将 玩家手牌变量设置未 volatile ,否则即使初始化了，其他线程也看不见，那么，volatile 是可以保证 cards 的内容可见性吗？有待测试
    ```
  
  - ```
    编号#12
    TODO: 服务器如何通知客户端，如其他玩家出牌之后，服务器需要通知其他客户端，但是 httpClient 不具备主动感知（或者说）操作 Channel 的能力
    原因：
    	框架设计
    状态：
    	已解决/guangmingdexin 2022/1/24
    解决方案：
    	1.httpClient 提前发送一个 http 请求，先挂起，当服务器处理完成之后，发送信息，但是需要解决的问题就是，服务器可能处理完成之后，客户端的请求都还没有抵达（不影响结果）
    ```
    
  - ```
    编号#13
    TODO: 关于 Socket 的奇怪现象，当进行一次 http 通信后，无论是先发起请求，还是先进行响应（http 保持长连接，复用同一个 Channel），都能进行正常通信
    原因：
    	业务逻辑，服务器推送其他玩家信息给客户端
    	游戏初始化后，客户端发现不是当前客户端回合，请求接受其他玩家手牌。服务端获取到出牌请求后，将出牌信息发送给其他客户端
    	会有如下两种情况
    	1.1 其他客户端的请求先抵达服务端 - 
    	1.2 服务端的的响应先抵达客户端
    	原因：我猜测应该是底层系统设计的原因，如下是猜测分析
    	在 Linux 中会有 ET/LT 事件通知模式，即 LT 只要缓冲区中还有数据，就会不断返回就绪事件，而对于第一种情况，发起请求即服务端的读缓冲区有数据，但是服务端没有响应，即客户端的读缓冲区没有数据，所以客户端Socket#read会被阻塞，直到服务端响应请求，在客户端的读缓冲中写入数据，此时 Socket#read 读取到数据，返回响应
    	第二种情况是服务端先将响应写入到客户端的读缓冲区，所以只要进行 Socket#read 就可以直接返回
    	所以业务都可以正常运行，但是每个 http 请求是共享同一个缓冲区，还是每一个 网络请求都可以拥有一个缓冲区？然后如果不是 http 长连接又会如何？是否能够确定 windwos 是 LT ?
    ```
  
  - ```
    #编号#14
    TODO：如果处理游戏事件带来的相关游戏状态的变化
    原因：
    	业务逻辑
    	1. 玩家出牌后，其他玩家有事件可以触发，但是有如下几种情况
    	1.1 pong/gang 与 hu 同时发送，不同玩家之间，那么应该先通知高优先级的玩家，等待玩家执行之后，再通知低优先级玩家，但是状态很难控制，有如下难点
    	一：出牌，之后，是否需要附带游戏事件信息，还是单独发送，尤其是对于低优先级的游戏事件，还需要携带额外信息
    	二：如果通知到服务端，高优先级的已经执行完了，可以继续执行低优先级的
    	1.2 多个 hu，
    	
    状态：
    	待解决
    解决方案：
    	一：将出牌信息和游戏事件分离，由客户端来判断，如果有游戏事件，则先获取游戏事件执行权，先通过服务端判断是否可以执行，如果不能执行，说明有其他更高级别的客户端挂起，则等待，直到获得游戏执行权，或者获取失败（比如该游戏事件受其他客户端影响可以取消）
    	二：服务端正常返回事件，客户端正常渲染，当客户选择之后，统一判断
    	   面临问题：1.事件优先级	2.是否需要收集完所有的玩家选择之后，才会执行
    ```
    
  - ```
    #编号#15
    TODO: 减少代码冗余，控制变量名称
    ```
  
  - ```
    #编号#16
    TODO: 正常无事件回合转换出现问题
    原因：
    	初步分析应该是多线程造成的问题，因为无法正常复现
    	流程分析：A 收到出牌请求，正常出牌，通知 B，同时 A 设置回合，B 收到消息后，重新请求回合
    	线程问题：在 A 设置回合之前，B 已经重新请求，但是请求回合为前一个数据
    状态：
    	已解决
    解决方案：
    	原子变量/锁都无法解决
    	1.上锁，对 room 上锁
    	2.改变流程，如果有事件，统一返回 -1，否则设置为下一回合
    
    ```
  
  - ```
    #编号#17
    TODO: 无法进行事件执行判断
    原因：
    	流程分析：A 先出牌，并通知 B，同时自身切换状态
    	1.无事件，A 进入 wait，B 进入 take，同时自身无事件，进入 takeout
    	2.B 出牌，进行事件判定，有事件，回合设置为 -1，同时 通知 A， B 自身进入 wait
    ```
  
  - ```
    #编号#18
    TODO：将游戏模块与其他模块切分
    ————————————————————————————————————————————————————————————————
    #编号#18-1
    TODO：关于统一各个模块之间的消息格式
    原因：
    	各个模块之间的消息格式不一致
    状态：
    	已解决
    解决方案：
    	1.抽离出一个统一的工具 jar 包，里面包含各种工具类（工作量较大，且各个业务模块之间也无法统一）
    	2.统一字段
    ————————————————————————————————————————————————————————————————
    #编号#18-2
    TODO：关于登录以及权限验证
    原因：
    	登录授权 TOKEN
    状态：
    	未解决
    解决方案：
    	1.用户点击登录 -> 调用第三方鉴权模块，返回一个 token -> 其他请求带上 token -> 第三方模块进行鉴权
    	1.1 如何对 token 的合理性校验？ 
    	1.2 如何对 保存 token 
    	1.3 如何刷新 token
    	1.4 如何融入网关
    	
    ```
    
  - ```
    #编号#19
    TODO：客户端-服务端建立心跳连接
    原因：
    	获取客户端状态
    状态：
    	未解决
    解决方案：
    	1.首先明确心跳一般流程：
    		客户端：
    		1.1 客户端发起请求（可能是调用第三方服务，也可能是请求游戏服务器）
    		服务端：
    		
    	2.定时不精确的问题
    	一.使用 httpClient 需要解决的问题
    	最终使用 服务端可以使用 netty 的 IdleState, 但是客户端又如何处理呢？如果想要仿照 netty 的 IdleState 是否需要对 httpclient 的进行改动，直接引入netty, 单独作为心跳模块设计，但是需要对整个业务重构，加大了复杂度
    	需要获取类似于 netty 的 Channel 其实就是 连接，获取对通道的使用情况，判断读空闲的发生，在读空闲时发送心跳包，
    	二.服务端主动进行空闲检测，在指定时间内，没有接受到数据，则主动发起请求
    	问题：
    	主要是可能影响到其他业务的正常进行，当服务端发起请求后，客户端的正常业务读取请求可能读取到这个数据
    ```
    
  - ```
    #编号#20
    TODO：建立异常补偿机制
    	1.网络异常
    	2.程序异常
    	3.系统异常
    ```
  
  - ```
    #编号#21
    TODO：如何将一轮游戏结束，并正常开始下一轮游戏
    原因：
    	状态切换
    状态：
    	未解决
    解决方案：
    	1.确定需要清理的资源
    		1.1 玩家手牌，事件牌 需要全部释放
    		1.2 房间需要重置为初始状态（待定）
    	2.确定各个玩家客户-服务端的状态机切换
    		2.1 首先确定结束条件，手牌池无牌/胡牌人数达到 playerCount - 1
    		2.2 当一个在摸牌/胡牌时都可能进入状态
    			2.2.1 摸牌状态，手牌池所有牌已经摸完，此时有的玩家可能处于等待状态，有的可能处于摸牌状态（等服务器响应），有的处于结束状态，响应结束事件就行了，客户端正常处理，服务端进入结束状态，等待客户下一步操作
    		2.3 当所有玩家都进入结束状态后，此局游戏结束
    ```
    
    
  
  

