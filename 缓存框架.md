#### **缓存框架**

##### Caffeine

- 缓存最核心的指标就是命中率

  影响因素

  - **淘汰策略**（当内存不足时，如何处理）
  - 过期清理策略（当缓存 key 过期时，如何处理）
  - 资源的占用

- 常用的淘汰策略

  - **FIFO(先进先出策略)**

  - **LFU(Least Frequently Used，即最不经常使用)**

    - 可以解决哪些问题/业务场景

      1. 可以取得较好的命中率（例如）

    - 缺点

      1. 它需要给每个记录项维护频率信息，每次访问都需要更新，这是个巨大的开销

      2. 对突发性的稀疏流量无力，因为前期经常访问的记录已经占用了缓存，偶然的流量不太可能会被保留下来，而且过去的一些大量被访问的记录在将来也不一定会使用上，这样就一直把“坑”占着了（例如一些新闻热点，往往在短时间内有大量关注）

  - **LRU(Least Recently Used，即最近最少使用)** 

    - 业务场景

      1. LRU 实现简单

      2. 对突发性的稀疏流量（sparse bursts）表现很好

    - 缺点

      1. 偶发性、周期性的批量操会降低缓存的命中率，对缓存造成污染（比如用户登录之后就退出）

  - **TinyLFU**

    - 业务场景：

      1. 解决 LFU 的缺陷 1

         如何解决：通过使用 Count-min Sketch 算法计算出现频率，降低访问开销（不是简单的使用`HashMap`，这太消耗内存了）

    - 缺点

      1. 无法解决偶然的流量带来的问题

  - **W-TinyLFU 算法**

    - 业务场景：解决 LFU 的缺陷

- 创建

  - **创建一个限制容量 Cache**

    ```java
    Cache<String, Object> cache = Caffeine
                                .newBuilder()
                                //设置缓存的 Entries 个数最多不超过1000个
                                .maximumSize(1000)
                                .build();
    ```

  - **创建一个自定义权重限制容量的 Cache**

- 高级特性/源码阅读/3.x 以上只支持 JDK 11 以上了

  | 特性                                   | 作用 |
  | -------------------------------------- | ---- |
  | **W-TinyLFU 算法**                     |      |
  | **高性能的 readBuffer 和 WriteBuffer** |      |
  | **时间轮算法**                         |      |
  | **软引用和弱引用**                     |      |
  | **消除伪共享**                         |      |
  | **`CompletableFuture`异步**            |      |

  **W-TinyLFU 算法**

  - 前置知识：Count–Min Sketch 算法介绍

    -  定义：一个可以用来计数的算法，在数据大小非常大时，一种高效的计数算法，通过牺牲准确性提高的效率

    - 参数：

      - Hash 哈希函数数量： K
      - 计数表格列的数量： M
      - 内存中用空间： K * M * 每个元素所占空间

    - 案例

      我们规定一个 M=5,K=3 的 Count-min Sketch，用来计数，其中所有hash函数如下（所有hash函数的结果需，mod M）

      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\hx.png)

      初始状态

      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\start.jpg)

      首先，向里面添加字母**B**

      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\middle.jpg)

      接下来，我们查询字母**A**，最终 A 出现的次数为 0

      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\result.png)

      源码解读

      ```java
      // com.github.benmanes.caffeine.cache#FrequencySketch
      
      // 一些种子数，来源与几种不同的 hash 算法
      static final long[] SEED = { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
            0xc3a5c85c97cb3127L, 0xb492b66fbe98f273L, 0x9ae16a3b2f90404fL, 0xcbf29ce484222325L};
      
      static final long RESET_MASK = 0x7777777777777777L;
      
      static final long ONE_MASK = 0x1111111111111111L;
      
      // 进行 reset 的阈值
      int sampleSize;
      
      //为了快速根据hash值得到table的index值的掩码
      //table的长度size一般为2的n次方，而tableMask为size-1，这样就可以通过&操作来模拟取余操作
      int tableMask;
      
      // 存储数据的一维long数组
      long[] table;
      
      // 
      int size;
      ```
      
      ```java
      // com.github.benmanes.caffeine.cache.FrequencySketch#increment
      // 增加元素的频率
      public void increment(E e) {
          // ... 判断是否进行了初始化
      
          // 根据key的hashCode通过一个哈希函数得到一个新的hashCode值
          // #spread 再次进行类似于hash操作，减少了hash碰撞（估计大佬们都觉得hash碰撞是一个低效的操作）
          // 很多框架都使用了：(x >>> 16) ^ x 来降低 hash 冲突
          int hash = spread(e.hashCode());
          
          /**
          * 在 Count–Min Sketch 算法中，对一个 key 进行多次 hash 函数后，index 到多个数组位置后进行累加，查询时取多个值中的最小值即可
          * caffeine 对此进行了优化
          * 1.Count–Min Sketch 使用了二维数组，Caffeine 只是用了一个一维的数组
          * 2.Caffeine 对缓存的访问频率进行了限制，记录的频率不超过 15次
          * 3.Caffeine 有一个机制来对这个频率进行衰退减半
          * 因此 Caffeine 将一个 long 分成 16 份，每一份都会对应一个 hash 计算后的频率
          * （每一份 4 bit，不超过 15，将存储效率提高了 16倍）
          */
          // 这个start就是用来定位到是哪一个等分的，用hash值低两位作为随机数，再左移2位，得到一个小于16的值
          int start = (hash & 3) << 2;
      
          // #indexOf 根据hash值和不同种子得到table的下标index
          // 这里通过四个不同的种子，得到四个不同的下标index（为什么是 4个？根据源码说明，应该是如此设置，性能得到了具体的提升）
          int index0 = indexOf(hash, 0);
          int index1 = indexOf(hash, 1);
          int index2 = indexOf(hash, 2);
          int index3 = indexOf(hash, 3);
      
          // #incrementAt 根据index和start(+1, +2, +3)的值，把table[index]对应的等分追加1
          boolean added = incrementAt(index0, start);
          added |= incrementAt(index1, start + 1);
          added |= incrementAt(index2, start + 2);
          added |= incrementAt(index3, start + 3);
      
          if (added && (++size == sampleSize)) {
            reset();
          }
        }
      
      
      /**
      * 假设第一步得到的 start = 12/0b1100
      * index0 = 1, index = 4, index = 6, index = 9
      * 第一个 index0: #incrementAt : offset = 48/0b110000 mask = 0b0...1111...0
      *		table[i] += 281474976710656/ 0...1... 0
      * 第二个 index1: #incrementAt : 
      */
      boolean incrementAt(int i, int j) {
        // 这个j表示16个等分的下标，那么offset就是相当于在64位中的下标（这个自己想想）
        in t offset = j << 2;
        //上面提到Caffeine把频率统计最大定为15，即0xfL
        // mask就是在64位中的掩码，即1111后面跟很多个0
        long mask = (0xfL << offset);
        // 如果&的结果不等于15，那么就追加1。等于15就不会再加了
        if ((table[i] & mask) != mask) {
          table[i] += (1L << offset);
          return true;
        }
        return false;
      }
      ```
      
      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\count-sketch-min.png)
      
      
  
  - 关于如何解决突发流量，以及保持缓存的热度
  
    - 保持热度
  
      ```java
      // 剔除掉过往频率很高但之后不经常的缓存，Caffeine 有一个 Freshness Mechanism。做法很简答，就是当整体的统计计数（当前所有记录的频率统计之和，这个数值内部维护）达到某一个值时，那么所有记录的频率统计除以 2
      // size变量就是所有记录的频率统计之，即每个记录加1，这个size都会加1
      // sampleSize一个阈值，从FrequencySketch初始化可以看到它的值为maximumSize的10倍
      // #incrementAt
      if (added && (++size == sampleSize)) {
            reset();
      }
      
       void reset() {
          int count = 0;
          for (int i = 0; i < table.length; i++) {
            count += Long.bitCount(table[i] & ONE_MASK);
            table[i] = (table[i] >>> 1) & RESET_MASK;
          }
          size = (size >>> 1) - (count >>> 2);
        }
      ```
  
    - 增加一个 window
  
      Caffeine 通过测试发现 TinyLFU 在面对突发性的稀疏流量（sparse bursts）时表现很差，因为新的记录（new items）还没来得及建立足够的频率就被剔除出去了，这就使得命中率下降
  
      ![](C:\Users\guangyong.deng\Desktop\博客\Cache\window-tiny-lfu.png)
  
      它主要包括两个缓存模块，主缓存是 SLRU（Segmented LRU，即分段 LRU），以及一个 Window Cache 缓存
      
      - SLRU
      
        SLRU 包括一个名为 protected 和一个名为 probation 的缓存区
      
      - Window Cache
      
        当有新的记录插入时，会先在 window 区呆一下，防止被直接剔除出去
      
      - 淘汰策略
      
        当 window 区满了，就会根据 LRU 把 candidate（即淘汰出来的元素）放到 probation 区，如果 probation 区也满了，就把 candidate 和 probation 将要淘汰的元素 victim，两个进行“PK”，胜者留在 probation，输者就要被淘汰了（疑问 如何将 probation 的元素升级到 protected 中，protected 中的元素又如何被淘汰？）
      
      - 默认配置比例
      
        Window 区配置为总容量的 1%
      
        剩余的 99%当中的 80%分给 protected 区，20%分给 probation 区
      
        可以进行动态的调整：应用程序的缓存随着时间变化比较快的话，那么增加 window 区的比例可以提高命中率，相反缓存都是比较固定不变的话，增加 Main Cache 区（protected 区 +probation 区）的比例会有较好的效果
      
      ```java
      // 具体位置在 BoundedLocalCache 的各种实现类中 比如 SILMS
      
      // 最大的个数限制
      long maximum;
      
      //当前的个数
      long weightedSize;
      
      //window区的最大限制
      long windowMaximum;
      
      //window区当前的个数
      long windowWeightedSize;
      
      //protected区的最大限制
      long mainProtectedMaximum;
      
      //protected区当前的个数
      long mainProtectedWeightedSize;
      
      //下一次需要调整的大小（还需要进一步计算）
      double stepSize;
      
      //window区需要调整的大小
      long adjustment;
      //命中计数
      int hitsInSample;
      //不命中的计数
      int missesInSample;
      //上一次的缓存命中率
      double previousSampleHitRate;
      
      final FrequencySketch<K> sketch;
      // window区的 LRU queue（FIFO）
      final AccessOrderDeque<Node<K, V>> accessOrderWindowDeque;
      // probation区的 LRU queue（FIFO）
      final AccessOrderDeque<Node<K, V>> accessOrderProbationDeque;
      // protected区的 LRU queue（FIFO）
      final AccessOrderDeque<Node<K, V>> accessOrderProtectedDeque;
      ```
      
      ```java
      // com.github.benmanes.caffeine.cache.BoundLocalCache#evictEntries
      @GuardedBy("evictionLock")
      void evictEntries() {
          if (!evicts()) {
              return;
          }
          // 淘汰window区的记录
          int candidates = evictFromWindow();
          // 淘汰Main区的记录
          evictFromMain(candidates);
      }
      
      // 根据W-TinyLFU，新的数据都会无条件的加到 window
      // 但是window是有大小限制，所以要“定期”做一下“维护”
      @GuardedBy("evictionLock")
      int evictFromWindow() {
          int candidates = 0;
          // 查看window queue的头部节点
          Node<K, V> node = accessOrderWindowDeque().peek();
          // 如果window区超过了最大的限制，那么就要把“多出来”的记录做处理
          while (windowWeightedSize() > windowMaximum()) {
              // The pending operations will adjust the size to reflect the correct weight
              if (node == null) {
                  break;
              }
      		// 获取下一个节点
              Node<K, V> next = node.getNextInAccessOrder();
              if (node.getPolicyWeight() != 0) {
                  // 设置 node 所在队列为 window 区
                  node.makeMainProbation();
                  // 从window区去掉
                  accessOrderWindowDeque().remove(node);
                  // 加入到probation queue，相当于把节点移动到probation区（晋升了）
                  accessOrderProbationDeque().add(node);
                   // 因为移除了一个节点，所以需要调整window的size
                  candidates++;
      
                  setWindowWeightedSize(windowWeightedSize() - node.getPolicyWeight());
              }
              node = next;
          }
      
          return candidates;
      }
      
      @GuardedBy("evictionLock")
        void evictFromMain(int candidates) {
          int victimQueue = PROBATION;
          // victim是probation queue的头部
          Node<K, V> victim = accessOrderProbationDeque().peekFirst();
          // candidate是probation queue的尾部，也就是刚从window晋升来的
          Node<K, V> candidate = accessOrderProbationDeque().peekLast();
            
          // 两个元素进行 pk
        }
      ```
      
      ```java
      // 与上次命中率之差的阈值
      static final double HILL_CLIMBER_RESTART_THRESHOLD = 0.05d;
      // 步长（调整）的大小（跟最大值maximum的比例）
      static final double HILL_CLIMBER_STEP_PERCENT = 0.0625d;
      // 步长的衰减比例
      static final double HILL_CLIMBER_STEP_DECAY_RATE = 0.98d;
      // 调整 window 区默认大小
       @GuardedBy("evictionLock")
        void climb() {
          if (!evicts()) {
            return;
          }
      	// 确定window需要调整的大小
          determineAdjustment();
          // 如果protected区有溢出，把溢出部分移动到probation区。因为下面的操作有可能需要调整到protected 区
          demoteFromMainProtected();
          long amount = adjustment();
          if (amount == 0) {
            return;
          } else if (amount > 0) {
            increaseWindow();
          } else {
            decreaseWindow();
          }
        }
      
      @GuardedBy("evictionLock")
      void determineAdjustment() {
        // 如果frequencySketch还没初始化，则返回
        if (frequencySketch().isNotInitialized()) {
          setPreviousSampleHitRate(0.0);
          setMissesInSample(0);
          setHitsInSample(0);
          return;
        }
        // 总请求量 = 命中 + miss
        int requestCount = hitsInSample() + missesInSample();
        // 没达到sampleSize则返回
        // 默认下sampleSize = 10 * maximum。用sampleSize来判断缓存是否足够”热“。
        if (requestCount < frequencySketch().sampleSize) {
          return;
        }
      
        // 命中率的公式 = 命中 / 总请求
        double hitRate = (double) hitsInSample() / requestCount;
        // 命中率的差值
        // 这个差值具体说明什么？
        // 会根据这个差值来调整 window 区的大小
        double hitRateChange = hitRate - previousSampleHitRate();
        // 本次调整的大小，是由命中率的差值和上次的stepSize决定的
        /**
        *	模拟流程：假设 hitRateChange 为 0.1 stepSize() 为 0
        *			amount = 0, nextStepSize 为 0.0625 * maximum
        *			
        *			hitRateChange 为 0.2 stepSize() 为 0.0625 * maximum
        *			amount = 0.0625 * maximum
        *			nextStep = 0.0625 * maximum
        *
        *			hitRateChange 为 0.005 amount = 0.0625 * maximum
        *			nextStep = 0.98 * amount
        *			
        *			hitRateChange 为 -0.005 amount = -0.98 * amount
        *			nextStep = 0.98 * (-0.98 * amount)
        *			
        */
        double amount = (hitRateChange >= 0) ? stepSize() : -stepSize();
        // 下次的调整大小：如果命中率的之差大于0.05，则重置为0.065 * maximum，否则按照0.98来进行衰减
        // 如果命中率变化增加，增加 window 区大小
        // 如果命中率减少，减少 window 区大小
        // 
        double nextStepSize = (Math.abs(hitRateChange) >= 0.05)
            ? 0.0625 * maximum() * (amount >= 0 ? 1 : -1)
            : 0.98 * amount;
          
        setPreviousSampleHitRate(hitRate);
        setAdjustment((long) amount);
        setStepSize(nextStepSize);
        setMissesInSample(0);
        setHitsInSample(0);
      }
      
      
      @GuardedBy("evictionLock")
      void increaseWindow() {
      	// 从这个比较可以看出 window 区的增强，是通过调整 protected 区来完成的！
          // 增加的区间不能超出 protected 区间的大小-- 为啥是先调整 protected 区间的大小，那如何确定如何调整
          long quota = Math.min(adjustment(), mainProtectedMaximum());
          
          // ...
          demoteFromMainProtected();
      }
      ```
    
  - 异步的高性能读写
  
    - 并发条件下，对缓存数据加锁，但是，对于一些热点数据，这种做法还是避免不了频繁的锁竞争
  
    - 并发条件下，先把操作记录在缓冲区，然后在合适的时机异步、批量地执行缓冲区中的内容。但在执行缓冲区的内容时，也是需要在缓冲区加上同步锁的，不然存在并发问题，只不过这样就可以把对锁的竞争从缓存数据转移到对缓冲区上（数据库系统的 WAL（Write-Ahead Logging）思想，即先写日志再执行操作）
  
      
  
  
  
  ​	
  
  

